"""
Copyright (c) 2014 Floris van Doorn (c) 2016 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn, Leonardo de Moura, Jeremy Avigad, Mario Carneiro
"""

import number_theory::main

# Basic operations on the natural numbers
#
# This file builds on `Mathlib/Data/Nat/Init.lean` by adding basic lemmas on natural numbers
# depending on Mathlib definitions.
#
# See note [foundational algebra order theory].

# We don't want to import the algebraic hierarchy in this file.

# succ, pred

# Lean4: lemma succ_injective : Injective Nat.succ := @succ.inj

know @succ_injective(a, b N):
    a + 1 = b + 1
    =>:
        a = b

# div

# pow

# Lean4: lemma pow_left_injective (hn : n ≠ 0) : Injective (fun a : ℕ ↦ a ^ n) := by simp [Injective, le_antisymm_iff, Nat.pow_le_pow_iff_left hn]

know @pow_left_injective(n N, a, b N):
    n != 0
    a ^ n = b ^ n
    =>:
        a = b

# Lean4: protected lemma pow_right_injective (ha : 2 ≤ a) : Injective (a ^ ·) := by simp [Injective, le_antisymm_iff, Nat.pow_le_pow_iff_right ha]

know @pow_right_injective(a N, n, m N):
    2 <= a
    a ^ n = a ^ m
    =>:
        n = m

# Recursion and induction principles
#
# This section is here due to dependencies -- the lemmas here require some of the lemmas
# proved above, and some of the results in later sections depend on the definitions in this section.

# Note: leRecOn functions are complex recursive functions that would need more context
# to translate properly. These are skipped for now as they require understanding
# of the specific recursive structure used in Lean4.

# Lean4: lemma set_induction_bounded {S : Set ℕ} (hk : k ∈ S) (h_ind : ∀ k : ℕ, k ∈ S → k + 1 ∈ S) (hnk : k ≤ n) : n ∈ S

know @set_induction_bounded(S set, k, n N):
    k $in S
    forall k N: k $in S => k + 1 $in S
    k <= n
    =>:
        n $in S

# Lean4: lemma set_induction {S : Set ℕ} (hb : 0 ∈ S) (h_ind : ∀ k : ℕ, k ∈ S → k + 1 ∈ S) (n : ℕ) : n ∈ S

know @set_induction(S set, n N):
    0 $in S
    forall k N: k $in S => k + 1 $in S
    =>:
        n $in S

# mod, dvd

# Definition of divisible
exist_prop k Z st divides(d Z, n Z):
    d != 0
    <=>:
        n = k * d

# Lean4: lemma dvd_left_injective : Function.Injective ((· ∣ ·) : ℕ → ℕ → Prop) := fun _ _ h => dvd_right_iff_eq.mp fun a => iff_of_eq (congr_fun h a)

know @dvd_left_injective(a, b N):
    forall c N => $divides(a, c) <=> $divides(b, c)
    =>:
        a = b

# Lean4: protected lemma dvd_sub_self_left {n m : ℕ} : n ∣ n - m ↔ m = 0 ∨ n ≤ m

know @dvd_sub_self_left(n, m N):
    forall => divides(n, n - m) <=> or(m = 0, n <= m)

# Lean4: protected lemma dvd_sub_self_right {n m : ℕ} : n ∣ m - n ↔ n ∣ m ∨ m ≤ n

know @dvd_sub_self_right(n, m N):
    forall => divides(n, m - n) <=> or(n | m, m <= n)
